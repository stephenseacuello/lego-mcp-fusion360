"""
Edge Runtime - Edge Computing Engine

LegoMCP World-Class Manufacturing System v5.0
Phase 25: Edge Computing & IIoT

Provides edge computing capabilities:
- Local data processing
- Rule-based automation
- Offline operation support
- Cloud synchronization
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Callable, Any
from enum import Enum
import uuid
import threading
import time


class EdgeRuleOperator(Enum):
    """Operators for edge rules."""
    EQUALS = "=="
    NOT_EQUALS = "!="
    GREATER_THAN = ">"
    LESS_THAN = "<"
    GREATER_OR_EQUAL = ">="
    LESS_OR_EQUAL = "<="
    CONTAINS = "contains"
    NOT_CONTAINS = "not_contains"


class EdgeActionType(Enum):
    """Types of edge actions."""
    ALERT = "alert"
    LOG = "log"
    COMMAND = "command"
    WEBHOOK = "webhook"
    AGGREGATE = "aggregate"
    TRANSFORM = "transform"


@dataclass
class EdgeRule:
    """An edge processing rule."""
    rule_id: str
    name: str
    description: str
    device_filter: Optional[str]
    condition_field: str
    condition_operator: EdgeRuleOperator
    condition_value: Any
    action_type: EdgeActionType
    action_config: Dict
    priority: int = 5
    enabled: bool = True
    cooldown_seconds: int = 60
    last_triggered: Optional[datetime] = None
    trigger_count: int = 0


@dataclass
class EdgeDataPoint:
    """A data point for edge processing."""
    point_id: str
    device_id: str
    tag: str
    value: Any
    quality: str  # good, bad, uncertain
    timestamp: datetime
    processed: bool = False


@dataclass
class EdgeAlert:
    """An alert generated by edge rules."""
    alert_id: str
    rule_id: str
    device_id: str
    message: str
    severity: str  # critical, warning, info
    value: Any
    threshold: Any
    timestamp: datetime
    acknowledged: bool = False


class EdgeRuntime:
    """
    Edge computing runtime for local data processing.

    Processes data streams locally, executes rules, and
    manages cloud synchronization for offline operation.
    """

    def __init__(self):
        self.rules: Dict[str, EdgeRule] = {}
        self.data_buffer: List[EdgeDataPoint] = []
        self.alerts: List[EdgeAlert] = []
        self.aggregations: Dict[str, Dict] = {}
        self.cloud_connected = True
        self.sync_queue: List[Dict] = []
        self._running = False
        self._process_thread: Optional[threading.Thread] = None
        self._setup_default_rules()

    def _setup_default_rules(self):
        """Set up default edge rules."""
        self.rules = {
            'high-temp-alert': EdgeRule(
                rule_id='high-temp-alert',
                name='High Temperature Alert',
                description='Alert when nozzle temperature exceeds threshold',
                device_filter='3d_printer',
                condition_field='nozzle_temp',
                condition_operator=EdgeRuleOperator.GREATER_THAN,
                condition_value=260,
                action_type=EdgeActionType.ALERT,
                action_config={
                    'severity': 'warning',
                    'message': 'Nozzle temperature exceeds safe limit',
                },
                priority=1,
                cooldown_seconds=300,
            ),
            'low-temp-alert': EdgeRule(
                rule_id='low-temp-alert',
                name='Low Temperature Alert',
                description='Alert when nozzle temperature drops below threshold',
                device_filter='3d_printer',
                condition_field='nozzle_temp',
                condition_operator=EdgeRuleOperator.LESS_THAN,
                condition_value=180,
                action_type=EdgeActionType.ALERT,
                action_config={
                    'severity': 'warning',
                    'message': 'Nozzle temperature below printing threshold',
                },
                priority=2,
                cooldown_seconds=60,
            ),
            'environment-alert': EdgeRule(
                rule_id='environment-alert',
                name='Environment Temperature Alert',
                description='Alert when room temperature out of range',
                device_filter='sensor',
                condition_field='temperature',
                condition_operator=EdgeRuleOperator.GREATER_THAN,
                condition_value=30,
                action_type=EdgeActionType.ALERT,
                action_config={
                    'severity': 'info',
                    'message': 'Room temperature above optimal range',
                },
                priority=5,
                cooldown_seconds=600,
            ),
        }

    def ingest_data(self, data_point: EdgeDataPoint) -> List[EdgeAlert]:
        """
        Ingest a data point and process through rules.

        Args:
            data_point: Data point to process

        Returns:
            List of generated alerts
        """
        self.data_buffer.append(data_point)
        alerts = self._process_rules(data_point)

        # Update aggregations
        self._update_aggregations(data_point)

        # Mark as processed
        data_point.processed = True

        # Add to sync queue if offline
        if not self.cloud_connected:
            self.sync_queue.append({
                'type': 'data',
                'payload': {
                    'device_id': data_point.device_id,
                    'tag': data_point.tag,
                    'value': data_point.value,
                    'timestamp': data_point.timestamp.isoformat(),
                },
            })

        # Limit buffer size
        if len(self.data_buffer) > 10000:
            self.data_buffer = self.data_buffer[-10000:]

        return alerts

    def _process_rules(self, data_point: EdgeDataPoint) -> List[EdgeAlert]:
        """Process data point against all rules."""
        alerts = []

        for rule in self.rules.values():
            if not rule.enabled:
                continue

            # Check device filter
            if rule.device_filter and rule.device_filter not in data_point.device_id.lower():
                continue

            # Check condition field
            if data_point.tag != rule.condition_field:
                continue

            # Check cooldown
            if rule.last_triggered:
                cooldown_end = rule.last_triggered + timedelta(seconds=rule.cooldown_seconds)
                if datetime.utcnow() < cooldown_end:
                    continue

            # Evaluate condition
            if self._evaluate_condition(data_point.value, rule.condition_operator, rule.condition_value):
                alert = self._execute_action(rule, data_point)
                if alert:
                    alerts.append(alert)
                    rule.last_triggered = datetime.utcnow()
                    rule.trigger_count += 1

        return alerts

    def _evaluate_condition(
        self,
        value: Any,
        operator: EdgeRuleOperator,
        threshold: Any
    ) -> bool:
        """Evaluate a rule condition."""
        try:
            if operator == EdgeRuleOperator.EQUALS:
                return value == threshold
            elif operator == EdgeRuleOperator.NOT_EQUALS:
                return value != threshold
            elif operator == EdgeRuleOperator.GREATER_THAN:
                return float(value) > float(threshold)
            elif operator == EdgeRuleOperator.LESS_THAN:
                return float(value) < float(threshold)
            elif operator == EdgeRuleOperator.GREATER_OR_EQUAL:
                return float(value) >= float(threshold)
            elif operator == EdgeRuleOperator.LESS_OR_EQUAL:
                return float(value) <= float(threshold)
            elif operator == EdgeRuleOperator.CONTAINS:
                return str(threshold) in str(value)
            elif operator == EdgeRuleOperator.NOT_CONTAINS:
                return str(threshold) not in str(value)
        except (ValueError, TypeError):
            return False

        return False

    def _execute_action(
        self,
        rule: EdgeRule,
        data_point: EdgeDataPoint
    ) -> Optional[EdgeAlert]:
        """Execute rule action."""
        if rule.action_type == EdgeActionType.ALERT:
            alert = EdgeAlert(
                alert_id=str(uuid.uuid4()),
                rule_id=rule.rule_id,
                device_id=data_point.device_id,
                message=rule.action_config.get('message', 'Alert triggered'),
                severity=rule.action_config.get('severity', 'info'),
                value=data_point.value,
                threshold=rule.condition_value,
                timestamp=datetime.utcnow(),
            )
            self.alerts.append(alert)

            # Add to sync queue
            if not self.cloud_connected:
                self.sync_queue.append({
                    'type': 'alert',
                    'payload': {
                        'alert_id': alert.alert_id,
                        'rule_id': alert.rule_id,
                        'device_id': alert.device_id,
                        'message': alert.message,
                        'severity': alert.severity,
                        'timestamp': alert.timestamp.isoformat(),
                    },
                })

            return alert

        elif rule.action_type == EdgeActionType.LOG:
            # Log action (would write to local log file)
            pass

        elif rule.action_type == EdgeActionType.COMMAND:
            # Execute device command
            pass

        return None

    def _update_aggregations(self, data_point: EdgeDataPoint):
        """Update running aggregations."""
        key = f"{data_point.device_id}:{data_point.tag}"

        if key not in self.aggregations:
            self.aggregations[key] = {
                'count': 0,
                'sum': 0.0,
                'min': None,
                'max': None,
                'last_value': None,
                'last_update': None,
            }

        agg = self.aggregations[key]
        try:
            value = float(data_point.value)
            agg['count'] += 1
            agg['sum'] += value
            agg['min'] = min(agg['min'], value) if agg['min'] is not None else value
            agg['max'] = max(agg['max'], value) if agg['max'] is not None else value
            agg['last_value'] = value
            agg['last_update'] = data_point.timestamp
        except (ValueError, TypeError):
            pass

    def add_rule(self, rule: EdgeRule):
        """Add a new edge rule."""
        self.rules[rule.rule_id] = rule

    def remove_rule(self, rule_id: str) -> bool:
        """Remove an edge rule."""
        if rule_id in self.rules:
            del self.rules[rule_id]
            return True
        return False

    def get_aggregation(self, device_id: str, tag: str) -> Optional[Dict]:
        """Get aggregation for a device/tag combination."""
        key = f"{device_id}:{tag}"
        agg = self.aggregations.get(key)

        if agg and agg['count'] > 0:
            return {
                **agg,
                'avg': agg['sum'] / agg['count'],
            }
        return None

    def get_active_alerts(self, acknowledged: bool = False) -> List[EdgeAlert]:
        """Get active alerts."""
        return [
            a for a in self.alerts
            if a.acknowledged == acknowledged
        ]

    def acknowledge_alert(self, alert_id: str) -> bool:
        """Acknowledge an alert."""
        for alert in self.alerts:
            if alert.alert_id == alert_id:
                alert.acknowledged = True
                return True
        return False

    def set_cloud_connection(self, connected: bool):
        """Set cloud connection status."""
        self.cloud_connected = connected

    def get_sync_queue_size(self) -> int:
        """Get number of items pending sync."""
        return len(self.sync_queue)

    def sync_to_cloud(self) -> int:
        """Sync buffered data to cloud."""
        if not self.cloud_connected:
            return 0

        synced = len(self.sync_queue)
        self.sync_queue.clear()
        return synced

    def get_runtime_status(self) -> Dict:
        """Get edge runtime status."""
        return {
            'running': self._running,
            'cloud_connected': self.cloud_connected,
            'rules': {
                'total': len(self.rules),
                'enabled': len([r for r in self.rules.values() if r.enabled]),
            },
            'data': {
                'buffer_size': len(self.data_buffer),
                'aggregations': len(self.aggregations),
            },
            'alerts': {
                'total': len(self.alerts),
                'unacknowledged': len([a for a in self.alerts if not a.acknowledged]),
            },
            'sync': {
                'pending': len(self.sync_queue),
            },
        }


# Singleton instance
_edge_runtime: Optional[EdgeRuntime] = None


def get_edge_runtime() -> EdgeRuntime:
    """Get or create the edge runtime instance."""
    global _edge_runtime
    if _edge_runtime is None:
        _edge_runtime = EdgeRuntime()
    return _edge_runtime
